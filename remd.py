# -*- coding: utf-8 -*-
"""remd.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1v0zBfIFQO0g_hNGAUqIn57lr2g_j3GSq
"""

import time
from datetime import datetime
import numpy as np
import sympy as sym
import math
import array
from matplotlib import pyplot as plt
from mpl_toolkits.mplot3d import axes3d
from matplotlib import pyplot as sx
import matplotlib.mlab as mlab
from sklearn.neighbors import KernelDensity as kd
from scipy.stats.kde import gaussian_kde
from numpy import linspace
import random
from cmath import sqrt
atoms = 5
s = 2
dt = 300
copies = 5
u = 1
s = u*10
v_total =[[(i,n)for n in range(atoms)]for i in range(s)]




sigma = 1


g_store = []
steps = 2
x_store= [(0) for i in range (atoms)]
y_store= [(0) for i in range(atoms)]
min_value = 0.
max_value = 10.
delta = 4.
sig = 10/50
a = 2
kb = 1.98e-3
distance_store = []
dis_store = []
epsilon = 10


def rand_generator(a,b):
    val = random.uniform(a,b)
    return val

def potential(x):
     v = 4*epsilon*((sigma/x)**12-(sigma/x)**6)


     return(v)

def cut_off(x_new,y_new):
    if x_new > max_value:
       x_new -= max_value

    if y_new > max_value:
       y_new -= max_value
    if x_new <= min_value:
         x_new += max_value
    if y_new <= min_value:
         y_new += max_value

    return(x_new,y_new)


def min_image(x_ini,y_ini,l):

      x_gap = (x_ini-x_store[l])
      y_gap = (y_ini-y_store[l])
      if x_gap > max_value/2 :
                    x_gap = 10 - x_gap
      if y_gap > max_value/2:
                    y_gap = 10 -y_gap


      gap = math.sqrt(x_gap**2 +y_gap**2)

      v_later = potential(gap)
      return(v_later)

def remd(ex1_v,ex2_v,temp1,temp2):
        temp1 = temp1*300
        temp2 =temp2*300
        dE = ex2_v - ex1_v
        dbeta  = (1/kb)*(1/temp1)-(1/temp2)
        bolt = dE*dbeta
        exp_val = np.exp(bolt)
        r = rand_generator(0,1)
        if r <= exp_val:
            select = 1
        else:
            select = 0
        return select

def before_exchange(x,y,step,temp,dt):
    while x<y:
        ex1_v = 0
        ex2_v = 0
        temp1 = x
        temp2 = x+1
        for i in range(atoms):


            v11= v_total[temp1][i]
            ex1_v = ex1_v+v11

            v22 = v_total[temp2][i]
            ex2_v = ex2_v+v22
        select= remd(ex1_v,ex2_v,temp1,temp2)
        if select == 1:
            for i in range (atoms):


               ex1_x = rx_store[temp1][i][step]
               ex1_y = ry_store[temp1][i][step]
               ex1_v = v_total[temp1][i]

               ex2_x = rx_store[temp2][i][step]
               ex2_y = ry_store[temp2][i][step]
               ex2_v = v_total[temp2][i]


               rx_store[temp1][i][step] = ex2_x
               ry_store[temp1][i][step] = ex2_y
               v_total[temp1][i] = ex2_v
               rx_store[temp2][i][step] = ex1_x
               ry_store[temp2][i][step] = ex1_y
               v_total[temp2][i] = ex1_v

        x = x+2
        i = i + 2
        temp = temp+dt*2

def boltzmann(dE,T):
  a = (-1*dE)/(kb*T)
  exp_val = np.exp(a)
  return exp_val

def select(x_ini,y_ini,x_later,y_later,v_ini,v_later,T,acc):

  if v_later < v_ini:
    v_ini = v_later
    x_ini = x_later
    y_ini =y_later
    acc = acc+1
  else:
    dE = v_later-v_ini

    r = rand_generator(0,1)



    bolt = boltzmann(dE,T)

    if (r <= bolt):
      v_ini = v_later
      x_ini = x_later
      y_ini = y_later
      acc = acc+1

  return x_ini,y_ini,v_ini,acc

def move(x_ini,y_ini):
    x_new = x_ini + rand_generator(-1,1)*delta
    y_new = y_ini + rand_generator(-1,1)*delta

    xi,yi= cut_off(x_new,y_new)


    return xi,yi
acc = 0

def mc(temp,start,steps,dt,copies,acc,count1):

  for i in range(1,copies):
    t = atoms

    for n in range(start,steps):
          count1 = count1+1
          index= int(random.uniform(0,t))



          if n ==0:
              x_ini = rx_store[0][index][0]

              y_ini = ry_store[0][index][0]

          else:
              d = n -1

              x_ini = rx_store[i][index][d]

              y_ini = ry_store[i][index][d]

          x_ii,y_ii = move(x_ini,y_ini)
          gap1_store = []
          v_tot = 0

          for l in range(atoms):
              if l != index :

                if n ==0:
                        x_nei = rx_store[0][l][0]

                        y_nei = ry_store[0][l][0]

                else:

                        x_nei = rx_store[i][l][d]

                        y_nei = ry_store[i][l][d]



                x_gap = x_ii-x_nei
                y_gap = y_ii-y_nei
                if x_gap > max_value/2 :
                      x_gap = 10 - x_gap
                if y_gap > max_value/2:
                        y_gap = 10 -y_gap

                gap = math.sqrt(x_gap**2 + y_gap**2)
                v = potential(gap)
                v_tot = v_tot + v
                gap1_store.append(gap)


                o = (len(gap1_store))

          count = 0
          for b in range(o):
              if gap1_store[b] < sig:
                break
              else:
                count = count  +1




          if count == o:
                if n ==0:
                       v_ini = v_total[0][index]

                else:
                      v_ini = v_total[i][index]





                x_ini,y_ini,v_ini,acc = select(x_ini,y_ini,x_ii,y_ii,v_ini,v_tot,temp,acc)
                v_total[i][index] = v_ini




                rx_store[i][index][n] = x_ini


                ry_store[i][index][n] = y_ini



    temp = temp+dt
  return acc,count1
r = steps*4
rx_store = [[[(g,i,n)for n in range(r)]for i in range(atoms)]for g in range(copies)]
ry_store = [[[(g,i,n)for n in range(r)]for i in range(atoms)]for g in range(copies)]
vx_store = []
vy_store = []
dis_store = []

count = 0
p = 0



while (p < atoms):
    x_ini = rand_generator(0,10)
    y_ini = rand_generator(0,10)
    v_tot = 0
    if p == 0:
      for i in range(copies):
          for l in range(r):
              rx_store[i][p][l] = x_ini
              ry_store[i][p][l] = y_ini



      t = math.sqrt((x_ini)**2 + (y_ini)**2)
      v_ini = potential(t)
      for i in range(copies):
          v_total[i][p] = v_ini

    else:

        for i in range(p):
            dis_store.append(math.sqrt((x_ini-rx_store[0][i][0])**2 + (y_ini-ry_store[0][i][0])**2))

        count = 0
        for i in range(p):

          if dis_store[i] < sig:
            break

          else :
            count = count  +1
        if count == p:
          for i in range (p):
             s = dis_store[i]
             v = potential(s)

             v_tot = v_tot + v


          for i in range(copies):
              for l in range(r):
                  rx_store[i][p][l] = x_ini
                  ry_store[i][p][l] = y_ini
          for i in range(copies):
              v_total[i][p] = v_tot





xx_store = []
yy_store = []
for i in range(atoms):
      gx = rx_store[0][i][0]

      gy = ry_store[0][i][0]
      xx_store.append(gx)
      yy_store.append(gy)
plt.scatter(xx_store,yy_store)
plt.xlabel("x")
plt.ylabel("y")

x = 0

q = 1
acc = 0
count1 = 0
acc,count1 = mc(300,x,steps,300,copies,acc,count1)
xx_store = []
yy_store = []

dt = 300
count = 0
steps = 100
increments = steps
q = 2
temp = 300

y = 1
for i in range(y):
    count = count+1
    x = increments
    #print("x",x)
    r = increments -1

    before_exchange(1,copies,r,temp,dt)
    increments = x +steps
    acc,count1= mc(temp,x,increments,dt,copies,acc,count1)
    n = increments
    m = increments - 1
    p = copies -1
    before_exchange(2,p,m,temp,dt)
    increments  = increments + steps
    acc,count1 = mc(temp,n,increments,dt,copies,acc,count1)
    r = increments -1
    before_exchange(1,copies,r,temp,dt)
    n = increments
    increments  = increments + steps
    acc1,count1 = mc(temp,x,increments,dt,copies,acc,count1)
w = acc1
print("count",count1)
r = w/count1
print("acceptance rate",r)